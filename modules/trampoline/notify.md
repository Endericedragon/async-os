# 内核如何唤醒用户态阻塞的系统调用

## 不借助硬件机制

这种方式要求将用户态协程的 waker 指针通过寄存器传递给内核。waker 包含了用户态任务信息，以及对应的 wake() 方法。

但再内核处理完系统调用后，直接调用 wake() 方法会因为安全性的问题带来困难。以 riscv 架构为例：

riscv 不允许在 S 态执行带有 U 态标志位的代码，存在两种方式来解决：
1. 进入 U 态：需要通过 sret 进入 U 态，但这里还需要额外分配一个 U 态使用的栈，这与信号处理机制没有区别。
2. 取消 wake() 方法所在页的 U态标志位，使用 mprotect 取消这一页的 U 态标志位，并使用内核栈来临时执行 wake() 方法，但需要保证这一页的代码不被 U 态的协程执行

## 硬件通知机制

在执行完成之后，内核通过写控制器的端口来唤醒阻塞的用户态任务
