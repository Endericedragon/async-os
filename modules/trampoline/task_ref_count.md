# The count of TaskRef

这个模块用于描述任务控制块的引用计数的关系。

为什么会有关于这个问题的描述，是因为使用协程带来的，由于 Rust 协程的抽象，它提供的 Waker 需要根据 TaskRef 来构建，Waker 的 wake 方法提供了统一的回调函数，将 TaskRef 放入到就绪队列中，如果使用 noop 来获取构建 Waker，那么将无法利用 Rust 语言提供的良好抽象带来的好处，需要手动的唤醒任务。

这里的描述不涉及到那些在其余数据结构中的部分，只涉及到与任务调度相关的部分：

- 就绪队列
- CurrentTask
- Waker

1. 初始状态下，任务只会在就绪队列中存在一个引用；
2. 当调度器从就绪队列中取出一个任务时，它先会设置 CurrentTask，并且消耗掉从就绪队列中取出来的引用，保证只会存在一个引用。而运行任务的 Future 时，构建的 Waker 将会根据 CurrentTask 来构建，这里只会使用到 `&TaskRef`，不会使用 `task.clone()` 来增加引用计数。
3. 当协程执行完成完成后，CurrentTask 会清除掉内部的引用计数，从而销毁任务；当协程没有执行完毕，CurrentTask 不会清除引用计数，而只是清除掉任务的指针数值（包括在需要进行抢占时，抢占实际上也以为这个协程没有执行结束），这个任务实际上还存在与内存中，当调用 Waker.wake() 方法时，会将任务的引用计数放到调度器的就绪队列中，从而保证引用计数继续生效。

这种方式，减少了滥用智能指针引用计数带来的开销，但是也带来了麻烦，如果一个任务没有调用 Waker.wake() 方法，那么很有可能导致内存泄漏，无法释放任务。但按照 Rust 协程的模式，在协程返回 Pending 时，要么会调用 cx.waker().wake_by_ref() 将任务重新放入就绪队列；或者通过其他的方式，将 waker 注册到其余的阻塞队列中，在阻塞队列等待的条件成熟时，再调用 Waker.wake() 方法唤醒任务。因此这种可能的内存泄露问题，我们认为是可以接受的。

核心的宗旨是为了保证引用计数能够正常工作并且不会被滥用，从而利用 Rust 语言的所有权机制管理内存空间。
